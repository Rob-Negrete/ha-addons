name: Coverage Health Check

on:
  # Primary trigger: after CI completes successfully
  workflow_run:
    workflows: ["CI"]
    types:
      - completed
    branches: ["*"]
  # Manual trigger for testing/debugging
  workflow_dispatch:
    inputs:
      pr_number:
        description: "PR number to analyze"
        required: true
        type: string

permissions:
  contents: read
  pull-requests: write
  checks: write
  statuses: write

jobs:
  coverage-health:
    name: Check Coverage Health
    runs-on: ubuntu-latest
    # Only run when CI completes successfully OR manual workflow dispatch
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      (github.event_name == 'workflow_dispatch')

    steps:
      - name: Get PR info for workflow_run events
        id: pr-info
        run: |
          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            # For workflow_run events, get PR info from the triggering workflow
            # Check if PR exists by testing if the array has elements
            if [[ "${{ github.event.workflow_run.pull_requests[0].number || '' }}" != "" ]]; then
              PR_NUMBER="${{ github.event.workflow_run.pull_requests[0].number }}"
              PR_HEAD_SHA="${{ github.event.workflow_run.head_sha }}"
              echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
              echo "pr_head_sha=$PR_HEAD_SHA" >> $GITHUB_OUTPUT
              echo "event_type=workflow_run" >> $GITHUB_OUTPUT
            else
              echo "No PR associated with workflow run"
              exit 1
            fi
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # For manual dispatch, use provided PR number and fetch SHA
            PR_NUMBER="${{ github.event.inputs.pr_number }}"
            echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "event_type=workflow_dispatch" >> $GITHUB_OUTPUT
            # We'll fetch the SHA in the next step
          fi

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.pr-info.outputs.pr_head_sha || github.event.workflow_run.head_sha }}
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.10.18"

      - name: Download coverage artifacts from CI
        if: steps.pr-info.outputs.event_type == 'workflow_run'
        uses: actions/download-artifact@v4
        with:
          name: ci-coverage-reports
          path: ./coverage-artifacts/
          run-id: ${{ github.event.workflow_run.id }}

      - name: Use CI coverage reports
        if: steps.pr-info.outputs.event_type == 'workflow_run'
        run: |
          echo "ğŸ“¥ Using comprehensive coverage from CI workflow"
          if [ -d "coverage-artifacts" ]; then
            # Copy CI coverage reports with consistent naming for the enhanced script
            cp coverage-artifacts/face-rekon/coverage.xml coverage-unit.xml 2>/dev/null || echo "No unit coverage XML"
            cp coverage-artifacts/face-rekon/coverage-integration.xml coverage-integration.xml 2>/dev/null || echo "No integration coverage XML"
            cp coverage-artifacts/face-rekon/coverage.json coverage-unit.json 2>/dev/null || echo "No unit coverage JSON"
            cp coverage-artifacts/face-rekon/coverage-integration.json coverage-integration.json 2>/dev/null || echo "No integration coverage JSON"

            echo "âœ… Coverage reports from CI workflow downloaded"
            echo "ğŸ“Š Available coverage files:"
            ls -la coverage*.xml coverage*.json 2>/dev/null || echo "No coverage files found"
          else
            echo "âš ï¸  No CI coverage artifacts found"
          fi

      - name: Run comprehensive tests (fallback for manual dispatch)
        if: steps.pr-info.outputs.event_type == 'workflow_dispatch'
        run: |
          echo "ğŸ”„ Fallback: Running comprehensive tests directly"
          cd face-rekon
          pip install -r requirements-test.txt

          # Run unit tests with coverage
          QDRANT_PATH=/tmp/test_qdrant_unit \
          FACE_REKON_BASE_PATH=/tmp/test_faces \
          FACE_REKON_UNKNOWN_PATH=/tmp/test_unknowns \
          FACE_REKON_THUMBNAIL_PATH=/tmp/test_thumbnails \
          FACE_REKON_USE_EMBEDDED_QDRANT=true \
          python -m pytest tests/unit/ -c pytest-unit.ini \
            --cov=scripts \
            --cov-report=xml:coverage-pr.xml \
            --cov-report=json:coverage-pr.json \
            --cov-report=term-missing

          # Move coverage files to root with unit naming for consistency
          mv coverage-pr.xml ../coverage-unit.xml
          mv coverage-pr.json ../coverage-unit.json

          # Clean up temporary coverage files to avoid git conflicts
          rm -f .coverage .coverage.*

      - name: Get baseline coverage for main branch
        run: |
          # Clean any remaining coverage files before checkout
          rm -f face-rekon/.coverage face-rekon/.coverage.*
          git fetch origin main:main
          git checkout main

          cd face-rekon
          pip install -r requirements-test.txt || echo "Failed to install requirements on main branch"

          # Run baseline tests
          QDRANT_PATH=/tmp/test_qdrant_main \
          FACE_REKON_BASE_PATH=/tmp/test_faces_main \
          FACE_REKON_UNKNOWN_PATH=/tmp/test_unknowns_main \
          FACE_REKON_THUMBNAIL_PATH=/tmp/test_thumbnails_main \
          FACE_REKON_USE_EMBEDDED_QDRANT=true \
          python -m pytest tests/unit/ -c pytest-unit.ini \
            --cov=scripts \
            --cov-report=xml:coverage-main.xml \
            --cov-report=json:coverage-main.json \
            --cov-report=term-missing || true

          # Move coverage files to root
          mv coverage-main.xml ../coverage-main.xml 2>/dev/null || echo "No main coverage XML"
          mv coverage-main.json ../coverage-main.json 2>/dev/null || echo "No main coverage JSON"

          # Clean up temporary coverage files
          rm -f .coverage .coverage.*

      - name: Switch back to PR branch
        run: |
          git checkout ${{ steps.pr-info.outputs.pr_head_sha }}

      - name: Make coverage health script executable
        run: chmod +x .github/scripts/coverage-health.py

      - name: Run coverage health analysis
        id: coverage-health
        env:
          BASELINE_COVERAGE: "41.2"
        run: |
          # Use the enhanced script that auto-discovers and combines coverage files
          if [ -f "coverage-unit.xml" ]; then
            echo "ğŸ”„ Using comprehensive coverage analysis with auto-discovery"
            python .github/scripts/coverage-health.py coverage-unit.xml coverage-main.xml
          elif [ -f "coverage-pr.xml" ]; then
            echo "ğŸ”„ Fallback to single coverage file"
            python .github/scripts/coverage-health.py coverage-pr.xml coverage-main.xml
          else
            echo "âŒ No coverage files found"
            exit 1
          fi
        continue-on-error: true

      - name: Read coverage report
        id: coverage-report
        run: |
          if [[ -f "coverage-report.md" ]]; then
            # Extract key information from the report instead of passing the whole file
            coverage=$(grep "Current Coverage:" coverage-report.md | sed 's/.*Current Coverage:\*\* \([0-9.]*\)%.*/\1/' || echo "unknown")
            status=$(grep "Coverage Health Check:" coverage-report.md | sed 's/.*## \(.*\) Coverage Health Check:.*/\1/' || echo "unknown")
            echo "coverage=$coverage" >> $GITHUB_OUTPUT
            echo "status=$status" >> $GITHUB_OUTPUT
            echo "report_exists=true" >> $GITHUB_OUTPUT
          else
            echo "report_exists=false" >> $GITHUB_OUTPUT
            echo "coverage=unknown" >> $GITHUB_OUTPUT
            echo "status=unknown" >> $GITHUB_OUTPUT
          fi

      - name: Create/Update PR Comment
        uses: actions/github-script@v7
        with:
          script: |
            const coverage = '${{ steps.coverage-report.outputs.coverage }}';
            const status = '${{ steps.coverage-report.outputs.status }}';
            const reportExists = '${{ steps.coverage-report.outputs.report_exists }}' === 'true';

            let statusIcon = 'â“';
            if (status.includes('ğŸŸ¢')) statusIcon = 'ğŸŸ¢';
            else if (status.includes('ğŸŸ¡')) statusIcon = 'ğŸŸ¡';
            else if (status.includes('ğŸ”´')) statusIcon = 'ğŸ”´';

            const commentBody = `## ğŸ“Š Coverage Health Report

            ${statusIcon} **Status:** ${status.replace(/ğŸŸ¢|ğŸŸ¡|ğŸ”´/g, '').trim()}
            ğŸ“ˆ **Coverage:** ${coverage}%
            ğŸ“‹ **Report Generated:** ${reportExists ? 'Yes' : 'No'}

            <details>
            <summary>About Coverage Health Checks</summary>

            This automated check analyzes test coverage and provides status indicators:

            - ğŸŸ¢ **Green (Pass)**: Coverage maintained or improved (â‰¥41.2%)
            - ğŸŸ¡ **Amber (Warning)**: Minor coverage decrease (35-41.1%)
            - ğŸ”´ **Red (Fail)**: Significant coverage drop (<35%)

            The baseline coverage is set at **41.2%** based on the current codebase state.

            Coverage includes both unit and integration tests from CI workflow. This workflow automatically runs after CI completes successfully.
            </details>

            ---
            *Coverage health check powered by GitHub Actions*`;

            const prNumber = '${{ steps.pr-info.outputs.pr_number }}';

            // Find existing comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const existingComment = comments.data.find(comment =>
              comment.body.includes('## ğŸ“Š Coverage Health Report')
            );

            if (existingComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: commentBody
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: commentBody
              });
            }

      - name: Create Coverage Status Check
        uses: actions/github-script@v7
        if: always()
        with:
          script: |
            const fs = require('fs');

            let statusData = {
              state: 'error',
              description: 'Coverage analysis failed',
              context: 'coverage/health'
            };

            try {
              if (fs.existsSync('status-check.json')) {
                statusData = JSON.parse(fs.readFileSync('status-check.json', 'utf8'));
              }
            } catch (error) {
              console.log('Could not read status-check.json, using default error state');
            }

            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: '${{ steps.pr-info.outputs.pr_head_sha }}',
              state: statusData.state,
              target_url: `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              description: statusData.description,
              context: statusData.context
            });

      - name: Upload coverage reports as artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-reports
          path: |
            coverage-*.xml
            coverage-*.json
            coverage-report.md
            status-check.json
          retention-days: 30

      - name: Fail job if coverage is critically low
        run: |
          if [[ -f "status-check.json" ]]; then
            STATE=$(cat status-check.json | python -c "import sys, json; print(json.load(sys.stdin)['state'])")
            if [[ "$STATE" == "failure" ]]; then
              echo "âŒ Coverage health check failed - coverage is critically low"
              exit 1
            fi
          fi
