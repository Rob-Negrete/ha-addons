name: Coverage Health Check

on:
  # Primary trigger: after CI completes successfully
  workflow_run:
    workflows: ["CI"]
    types:
      - completed
    # Remove branch filter to ensure all CI runs trigger this workflow
    # The workflow_run event inherently runs on the default branch
  # Manual trigger for testing/debugging
  workflow_dispatch:
    inputs:
      pr_number:
        description: "PR number to analyze"
        required: true
        type: string
  # Alternative trigger: when CI status check completes
  check_run:
    types: [completed]

permissions:
  contents: read
  pull-requests: write
  checks: write
  statuses: write

jobs:
  coverage-health:
    name: Check Coverage Health
    runs-on: ubuntu-latest
    # Only run when CI completes successfully OR manual workflow dispatch OR relevant check_run
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      (github.event_name == 'workflow_dispatch') ||
      (github.event_name == 'check_run' && github.event.check_run.conclusion == 'success' && contains(github.event.check_run.name, 'Test Face Rekon'))

    steps:
      - name: Get PR info for all event types
        id: pr-info
        run: |
          echo "üîç Event debugging info:"
          echo "  Event name: ${{ github.event_name }}"
          echo "  Repository: ${{ github.repository }}"
          echo "  Ref: ${{ github.ref }}"

          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            echo "üìä Workflow run event details:"
            echo "  Workflow name: ${{ github.event.workflow_run.name }}"
            echo "  Conclusion: ${{ github.event.workflow_run.conclusion }}"
            echo "  Head SHA: ${{ github.event.workflow_run.head_sha }}"
            echo "  Head branch: ${{ github.event.workflow_run.head_branch }}"

            # Try to get PR info from workflow run event
            # Use jq to safely parse the pull_requests array
            PR_COUNT=$(echo '${{ toJson(github.event.workflow_run.pull_requests) }}' | jq '. | length')
            echo "  Pull requests count: $PR_COUNT"

            if [[ "$PR_COUNT" -gt 0 ]]; then
              PR_NUMBER=$(echo '${{ toJson(github.event.workflow_run.pull_requests) }}' | jq -r '.[0].number')
              PR_HEAD_SHA="${{ github.event.workflow_run.head_sha }}"
              echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
              echo "pr_head_sha=$PR_HEAD_SHA" >> $GITHUB_OUTPUT
              echo "event_type=workflow_run" >> $GITHUB_OUTPUT
              echo "‚úÖ Found PR #$PR_NUMBER with SHA $PR_HEAD_SHA"
            else
              echo "‚ÑπÔ∏è  No PR associated with workflow run"
              echo "üîç This might be a push to main or other non-PR event"
              echo "üìä Running coverage analysis for direct push to branch: ${{ github.event.workflow_run.head_branch }}"

              # Set outputs for non-PR workflow runs (e.g., direct pushes to main)
              PR_HEAD_SHA="${{ github.event.workflow_run.head_sha }}"
              echo "pr_head_sha=$PR_HEAD_SHA" >> $GITHUB_OUTPUT
              echo "event_type=workflow_run" >> $GITHUB_OUTPUT
              echo "is_direct_push=true" >> $GITHUB_OUTPUT
              echo "target_branch=${{ github.event.workflow_run.head_branch }}" >> $GITHUB_OUTPUT
              echo "‚úÖ Non-PR workflow run processed for branch ${{ github.event.workflow_run.head_branch }}"
            fi

          elif [[ "${{ github.event_name }}" == "check_run" ]]; then
            echo "üìä Check run event details:"
            echo "  Check name: ${{ github.event.check_run.name }}"
            echo "  Conclusion: ${{ github.event.check_run.conclusion }}"
            echo "  Head SHA: ${{ github.event.check_run.head_sha }}"

            # For check_run events, get PR info from the check_run context
            # We need to find the PR associated with this check run
            PR_HEAD_SHA="${{ github.event.check_run.head_sha }}"
            echo "pr_head_sha=$PR_HEAD_SHA" >> $GITHUB_OUTPUT
            echo "event_type=check_run" >> $GITHUB_OUTPUT
            echo "needs_pr_lookup=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Check run event processed, will lookup PR in next step"

          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # For manual dispatch, use provided PR number and fetch SHA
            PR_NUMBER="${{ github.event.inputs.pr_number }}"
            echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "event_type=workflow_dispatch" >> $GITHUB_OUTPUT
            echo "‚úÖ Manual dispatch for PR #$PR_NUMBER"
          fi

      - name: Lookup PR for check_run events
        if: steps.pr-info.outputs.needs_pr_lookup == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const sha = '${{ steps.pr-info.outputs.pr_head_sha }}';
            console.log(`üîç Looking up PR for SHA: ${sha}`);

            // Search for pull requests with this head SHA
            const { data: pulls } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });

            const matchingPR = pulls.find(pr => pr.head.sha === sha);

            if (matchingPR) {
              console.log(`‚úÖ Found PR #${matchingPR.number} for SHA ${sha}`);
              core.setOutput('pr_number', matchingPR.number.toString());
            } else {
              console.log(`‚ùå No open PR found for SHA ${sha}`);
              core.setFailed('No open PR found for this check run');
            }
        id: pr-lookup

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.pr-info.outputs.pr_head_sha || github.event.workflow_run.head_sha }}
          fetch-depth: 0
          lfs: true

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.10.18"

      - name: Debug workflow run info
        if: steps.pr-info.outputs.event_type == 'workflow_run'
        run: |
          echo "üîç Workflow run debugging info:"
          echo "  Workflow Run ID: ${{ github.event.workflow_run.id }}"
          echo "  Workflow Run Conclusion: ${{ github.event.workflow_run.conclusion }}"
          echo "  Head SHA: ${{ github.event.workflow_run.head_sha }}"
          echo "  Workflow Name: ${{ github.event.workflow_run.name }}"
          echo "  Event Type: ${{ steps.pr-info.outputs.event_type }}"

      - name: Download coverage artifacts from CI
        if: steps.pr-info.outputs.event_type == 'workflow_run'
        uses: dawidd6/action-download-artifact@v6
        with:
          name: ci-coverage-reports
          path: ./coverage-artifacts/
          run_id: ${{ github.event.workflow_run.id }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true
        id: download-artifacts

      - name: Use CI coverage reports or fallback
        if: steps.pr-info.outputs.event_type == 'workflow_run'
        run: |
          if [[ "${{ steps.download-artifacts.outcome }}" == "success" && -d "coverage-artifacts" ]]; then
            echo "üì• Using comprehensive coverage from CI workflow"
            echo "üìç Current working directory: $(pwd)"
            echo "üìÅ Contents of coverage-artifacts directory:"
            ls -la coverage-artifacts/

            # Copy CI coverage reports to /tmp (persists across git checkouts)
            # Files are extracted directly to coverage-artifacts/ (no face-rekon subdirectory)
            echo "üîÑ Copying coverage files to /tmp (survives git checkouts)..."
            mkdir -p /tmp/coverage-pr
            cp coverage-artifacts/coverage.xml /tmp/coverage-pr/coverage-unit.xml 2>/dev/null && echo "‚úÖ Copied unit coverage XML" || echo "‚ùå No unit coverage XML"
            cp coverage-artifacts/coverage-integration.xml /tmp/coverage-pr/coverage-integration.xml 2>/dev/null && echo "‚úÖ Copied integration coverage XML" || echo "‚ùå No integration coverage XML"
            cp coverage-artifacts/coverage.json /tmp/coverage-pr/coverage-unit.json 2>/dev/null && echo "‚úÖ Copied unit coverage JSON" || echo "‚ùå No unit coverage JSON"
            cp coverage-artifacts/coverage-integration.json /tmp/coverage-pr/coverage-integration.json 2>/dev/null && echo "‚úÖ Copied integration coverage JSON" || echo "‚ùå No integration coverage JSON"

            echo "‚úÖ Coverage reports from CI workflow processed"
            echo "üìç Coverage files saved to /tmp/coverage-pr/"
            echo "üìä Available coverage files in /tmp:"
            ls -la /tmp/coverage-pr/ 2>/dev/null || echo "No coverage files found"
          else
            echo "‚ö†Ô∏è  Unable to download CI coverage artifacts, falling back to running tests"
            echo "üìù Artifact download outcome: ${{ steps.download-artifacts.outcome }}"
            echo "üîÑ Running comprehensive tests as fallback"

            cd face-rekon
            pip install -r requirements-test.txt

            # Run unit tests with coverage
            QDRANT_PATH=/tmp/test_qdrant_unit \
            FACE_REKON_BASE_PATH=/tmp/test_faces \
            FACE_REKON_UNKNOWN_PATH=/tmp/test_unknowns \
            FACE_REKON_THUMBNAIL_PATH=/tmp/test_thumbnails \
            FACE_REKON_USE_EMBEDDED_QDRANT=true \
            python -m pytest tests/unit/ -c pytest-unit.ini \
              --cov=scripts \
              --cov-report=xml:coverage-fallback.xml \
              --cov-report=json:coverage-fallback.json \
              --cov-report=term-missing

            # Move coverage files to root with unit naming for consistency
            mv coverage-fallback.xml ../coverage-unit.xml
            mv coverage-fallback.json ../coverage-unit.json

            # Clean up temporary coverage files to avoid git conflicts
            rm -f .coverage .coverage.*

            echo "‚úÖ Fallback coverage completed"
          fi

      - name: Run comprehensive tests (for manual dispatch)
        if: steps.pr-info.outputs.event_type == 'workflow_dispatch'
        run: |
          echo "üîÑ Manual dispatch: Running comprehensive tests directly"
          cd face-rekon
          pip install -r requirements-test.txt

          # Run unit tests with coverage
          QDRANT_PATH=/tmp/test_qdrant_unit \
          FACE_REKON_BASE_PATH=/tmp/test_faces \
          FACE_REKON_UNKNOWN_PATH=/tmp/test_unknowns \
          FACE_REKON_THUMBNAIL_PATH=/tmp/test_thumbnails \
          FACE_REKON_USE_EMBEDDED_QDRANT=true \
          python -m pytest tests/unit/ -c pytest-unit.ini \
            --cov=scripts \
            --cov-report=xml:coverage-dispatch.xml \
            --cov-report=json:coverage-dispatch.json \
            --cov-report=term-missing

          # Move coverage files to root with unit naming for consistency
          mv coverage-dispatch.xml ../coverage-unit.xml
          mv coverage-dispatch.json ../coverage-unit.json

          # Clean up temporary coverage files to avoid git conflicts
          rm -f .coverage .coverage.*

      - name: Get baseline coverage for main branch
        run: |
          # Clean any remaining coverage files before checkout
          rm -f face-rekon/.coverage face-rekon/.coverage.*

          # Force discard all local changes including LFS files
          git reset --hard HEAD
          git clean -fd

          git fetch origin main:main
          git checkout -f main

          cd face-rekon
          pip install -r requirements-test.txt || echo "Failed to install requirements on main branch"

          # Run baseline tests
          QDRANT_PATH=/tmp/test_qdrant_main \
          FACE_REKON_BASE_PATH=/tmp/test_faces_main \
          FACE_REKON_UNKNOWN_PATH=/tmp/test_unknowns_main \
          FACE_REKON_THUMBNAIL_PATH=/tmp/test_thumbnails_main \
          FACE_REKON_USE_EMBEDDED_QDRANT=true \
          python -m pytest tests/unit/ -c pytest-unit.ini \
            --cov=scripts \
            --cov-report=xml:coverage-main.xml \
            --cov-report=json:coverage-main.json \
            --cov-report=term-missing || true

          # Move coverage files to root
          mv coverage-main.xml ../coverage-main.xml 2>/dev/null || echo "No main coverage XML"
          mv coverage-main.json ../coverage-main.json 2>/dev/null || echo "No main coverage JSON"

          # Clean up temporary coverage files
          rm -f .coverage .coverage.*

      - name: Switch back to PR branch
        run: |
          # Force discard all local changes including LFS files
          git reset --hard HEAD
          git clean -fd

          # Force checkout PR SHA
          git checkout -f ${{ steps.pr-info.outputs.pr_head_sha }}

      - name: Make coverage health script executable
        run: chmod +x .github/scripts/coverage-health.py

      - name: Run coverage health analysis
        id: coverage-health
        env:
          BASELINE_COVERAGE: "72.0"
        run: |
          # Restore coverage files from /tmp (where they were saved before git checkouts)
          echo "üîÑ Restoring coverage files from /tmp"
          if [ -d "/tmp/coverage-pr" ]; then
            echo "‚úÖ Found coverage files in /tmp/coverage-pr"
            cp /tmp/coverage-pr/* . 2>/dev/null && echo "‚úÖ Restored coverage files to working directory" || echo "‚ö†Ô∏è  No files to restore"
            ls -la /tmp/coverage-pr/
          else
            echo "‚ö†Ô∏è  No coverage files found in /tmp/coverage-pr"
          fi

          # Use the enhanced script that auto-discovers and combines coverage files
          echo "üîÑ Checking for coverage files"
          echo "üìç Current working directory: $(pwd)"
          echo "üìÅ Directory contents:"
          ls -la
          echo ""
          echo "üìä Looking for coverage files:"
          ls -la coverage*.xml coverage*.json 2>/dev/null || echo "‚ùå No coverage files found with pattern coverage*.xml or coverage*.json"

          if [ -f "coverage-unit.xml" ]; then
            echo "‚úÖ Found unit coverage file"
            if [ -f "coverage-integration.xml" ]; then
              echo "‚úÖ Found integration coverage file - script will auto-discover it"
            else
              echo "‚ö†Ô∏è  No integration coverage file found"
            fi

            echo "üîÑ Running coverage analysis with auto-discovery"
            python .github/scripts/coverage-health.py coverage-unit.xml coverage-main.xml
          else
            echo "‚ùå No unit coverage file found for analysis"
            echo "üìÅ Files in current directory:"
            ls -la
            echo "üìÅ Checking if files exist in /tmp:"
            ls -la /tmp/coverage-pr/ 2>/dev/null || echo "No /tmp/coverage-pr directory"
            echo "üìÅ Checking if files exist in subdirectories:"
            find . -name "coverage*.xml" -o -name "coverage*.json" 2>/dev/null || echo "No coverage files found anywhere"
            exit 1
          fi
        continue-on-error: true

      - name: Read coverage report
        id: coverage-report
        run: |
          if [[ -f "coverage-report.md" ]]; then
            # Extract key information from the report instead of passing the whole file
            coverage=$(grep "Current Coverage:" coverage-report.md | sed 's/.*Current Coverage:\*\* \([0-9.]*\)%.*/\1/' || echo "unknown")
            status=$(grep "Coverage Health Check:" coverage-report.md | sed 's/.*## \(.*\) Coverage Health Check:.*/\1/' || echo "unknown")
            echo "coverage=$coverage" >> $GITHUB_OUTPUT
            echo "status=$status" >> $GITHUB_OUTPUT
            echo "report_exists=true" >> $GITHUB_OUTPUT
          else
            echo "report_exists=false" >> $GITHUB_OUTPUT
            echo "coverage=unknown" >> $GITHUB_OUTPUT
            echo "status=unknown" >> $GITHUB_OUTPUT
          fi

      - name: Create/Update PR Comment
        if: steps.pr-info.outputs.pr_number && steps.pr-info.outputs.is_direct_push != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const reportExists = '${{ steps.coverage-report.outputs.report_exists }}' === 'true';

            let commentBody;

            if (reportExists && fs.existsSync('coverage-report.md')) {
              // Read the full markdown report with function-level details
              commentBody = fs.readFileSync('coverage-report.md', 'utf8');

              // Add footer
              commentBody += `\n\n---\n*Coverage health check powered by GitHub Actions*`;
            } else {
              // Fallback to simple summary if report doesn't exist
              const coverage = '${{ steps.coverage-report.outputs.coverage }}';
              const status = '${{ steps.coverage-report.outputs.status }}';

              let statusIcon = '‚ùì';
              if (status.includes('üü¢')) statusIcon = 'üü¢';
              else if (status.includes('üü°')) statusIcon = 'üü°';
              else if (status.includes('üî¥')) statusIcon = 'üî¥';

              commentBody = `## ${statusIcon} Coverage Health Report\n\n` +
                `**Status:** ${status.replace(/üü¢|üü°|üî¥/g, '').trim()}\n` +
                `**Coverage:** ${coverage}%\n` +
                `**Report Generated:** No\n\n` +
                `---\n` +
                `*Coverage health check powered by GitHub Actions*`;
            }

            // Get PR number from either pr-info or pr-lookup steps
            const prNumber = '${{ steps.pr-info.outputs.pr_number }}' || '${{ steps.pr-lookup.outputs.pr_number }}';

            // Find existing comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const existingComment = comments.data.find(comment =>
              comment.body.includes('Coverage Health Check')
            );

            if (existingComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: commentBody
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: commentBody
              });
            }

      - name: Log coverage results for non-PR events
        if: steps.pr-info.outputs.is_direct_push == 'true'
        run: |
          echo "üìä Coverage Analysis Results for Direct Push"
          echo "üîó Branch: ${{ steps.pr-info.outputs.target_branch }}"
          echo "üìà Coverage: ${{ steps.coverage-report.outputs.coverage }}%"
          echo "üìã Status: ${{ steps.coverage-report.outputs.status }}"
          echo "‚ÑπÔ∏è  Skipping PR comment creation for non-PR event"

      - name: Create Coverage Status Check
        uses: actions/github-script@v7
        if: always()
        with:
          script: |
            const fs = require('fs');

            let statusData = {
              state: 'error',
              description: 'Coverage analysis failed',
              context: 'coverage/health'
            };

            try {
              if (fs.existsSync('status-check.json')) {
                statusData = JSON.parse(fs.readFileSync('status-check.json', 'utf8'));
              }
            } catch (error) {
              console.log('Could not read status-check.json, using default error state');
            }

            // Get SHA from pr-info step (covers workflow_run, check_run, and workflow_dispatch)
            const headSha = '${{ steps.pr-info.outputs.pr_head_sha }}' || '${{ github.event.workflow_run.head_sha }}';

            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: headSha,
              state: statusData.state,
              target_url: `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              description: statusData.description,
              context: statusData.context
            });

      - name: Upload coverage reports as artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-reports
          path: |
            coverage-*.xml
            coverage-*.json
            coverage-report.md
            status-check.json
          retention-days: 30

      - name: Fail job if coverage is critically low
        run: |
          if [[ -f "status-check.json" ]]; then
            STATE=$(cat status-check.json | python -c "import sys, json; print(json.load(sys.stdin)['state'])")
            if [[ "$STATE" == "failure" ]]; then
              echo "‚ùå Coverage health check failed - coverage is critically low"
              exit 1
            fi
          fi
