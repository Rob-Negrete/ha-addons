"""
Integration tests for database operations.
Tests real Qdrant operations with actual ML models for true integration testing.
"""
import os

import numpy as np
import pytest
from PIL import Image


@pytest.mark.integration
class TestDatabaseIntegration:
    """Integration tests for database operations with real Qdrant"""

    def test_database_initialization(self, clean_test_env, shared_ml_models):
        """
        Integration test: Verify Qdrant database initialization
        """
        # Use the real models from session-scoped fixture
        clasificador = shared_ml_models["clasificador"]

        # Verify Qdrant adapter exists and is functional
        assert hasattr(clasificador, "get_qdrant_adapter")
        qdrant_adapter = clasificador.get_qdrant_adapter()
        assert qdrant_adapter is not None
        assert hasattr(qdrant_adapter, "save_face")
        assert hasattr(qdrant_adapter, "search_face")

        # Verify test database directory exists
        assert os.path.exists(clean_test_env["qdrant_path"])

    def test_save_unknown_face_database_integration(
        self, clean_test_env, test_images, shared_ml_models
    ):
        """
        Integration test: Save unknown face to real database using actual ML models
        """
        clasificador = shared_ml_models["clasificador"]

        # Create a real test image file
        test_image_path = os.path.join(clean_test_env["tmp_path"], "test_face.jpg")

        # Ensure directory exists
        os.makedirs(os.path.dirname(test_image_path), exist_ok=True)

        # Save test image to file system
        img = Image.new("RGB", (200, 200), "red")
        img.save(test_image_path)

        # Get initial database count
        initial_count = len(clasificador.db.all())

        # Test save_unknown_face function with real image
        event_id = "test_event_db_integration"

        # This should work with the real ML models - but might not find a face
        # in a red square
        # That's ok for this integration test - we're testing the database operations
        clasificador.save_unknown_face(test_image_path, event_id)

        # For integration testing, we don't need a face to be detected
        # We just need to verify the database operations work
        # The function should handle "no face detected" gracefully
        final_count = len(clasificador.db.all())

        # Database should either have same count (no face detected) or +1 (face saved)
        assert final_count >= initial_count

    def test_identify_face_database_integration(
        self, clean_test_env, known_face_data, test_images, shared_ml_models
    ):
        """
        Integration test: Identify face using real database lookup
        """
        clasificador = shared_ml_models["clasificador"]

        # First, add a known face to the database for testing
        clasificador.db.insert(known_face_data)

        # Create test image
        test_image_path = os.path.join(clean_test_env["tmp_path"], "known_face.jpg")

        # Ensure directory exists
        os.makedirs(os.path.dirname(test_image_path), exist_ok=True)

        img = Image.new("RGB", (200, 200), "blue")
        img.save(test_image_path)

        # Test identification - this might return None if no face is detected
        # in solid color image
        # That's fine for integration testing - we're testing the database
        # query functionality
        result = clasificador.identify_face(test_image_path)

        # The result should either be None (no face detected) or a dict
        # (face identified)
        assert result is None or isinstance(result, dict)

    def test_get_unclassified_faces_database_integration(
        self, clean_test_env, sample_face_data, shared_ml_models
    ):
        """
        Integration test: Get unclassified faces from real database
        """
        clasificador = shared_ml_models["clasificador"]

        # Clear database for clean test
        clasificador.db.truncate()

        # Insert test data - mix of classified and unclassified
        test_faces = [
            {**sample_face_data, "face_id": "unclassified_1", "name": "unknown"},
            {**sample_face_data, "face_id": "classified_1", "name": "John Doe"},
            {**sample_face_data, "face_id": "unclassified_2", "name": "unknown"},
            {**sample_face_data, "face_id": "classified_2", "name": "Jane Smith"},
        ]

        for face in test_faces:
            clasificador.db.insert(face)

        # Get unclassified faces
        unclassified = clasificador.get_unclassified_faces()

        # Verify results
        assert len(unclassified) == 2
        unclassified_ids = [face["face_id"] for face in unclassified]
        assert "unclassified_1" in unclassified_ids
        assert "unclassified_2" in unclassified_ids
        # Note: name may be None or "unknown" depending on storage format
        assert all(face["name"] in [None, "unknown"] for face in unclassified)

    def test_update_face_database_integration(
        self, clean_test_env, sample_face_data, shared_ml_models
    ):
        """
        Integration test: Update face information in real database
        """
        clasificador = shared_ml_models["clasificador"]

        # Clear database for clean test
        clasificador.db.truncate()

        # Insert unclassified face
        clasificador.db.insert(sample_face_data)

        # Update face information
        update_data = {
            "name": "Updated Name",
            "relationship": "family",
            "confidence": "high",
        }

        clasificador.update_face(sample_face_data["face_id"], update_data)

        # Verify update
        updated_face = clasificador.db.get(
            clasificador.Face.face_id == sample_face_data["face_id"]
        )

        assert updated_face is not None
        assert updated_face["name"] == "Updated Name"
        assert updated_face["relationship"] == "family"
        assert updated_face["confidence"] == "high"

    def test_get_face_database_integration(
        self, clean_test_env, sample_face_data, shared_ml_models
    ):
        """
        Integration test: Get specific face from real database
        """
        clasificador = shared_ml_models["clasificador"]

        # Clear database for clean test
        clasificador.db.truncate()

        # Insert test face
        clasificador.db.insert(sample_face_data)

        # Get face by ID
        result = clasificador.get_face(sample_face_data["face_id"])

        # Verify result - get_face now returns a single dict, not a list
        assert result is not None
        assert result["face_id"] == sample_face_data["face_id"]
        assert result["name"] == sample_face_data["name"]

    def test_database_persistence_across_operations(
        self, clean_test_env, sample_face_data, shared_ml_models
    ):
        """
        Integration test: Verify database persistence across multiple operations
        """
        clasificador = shared_ml_models["clasificador"]

        # Clear database for clean test
        clasificador.db.truncate()

        # Test multiple database operations in sequence
        face_id = "persistence_test_face"

        # 1. Insert face
        test_face = {**sample_face_data, "face_id": face_id}
        clasificador.db.insert(test_face)

        # 2. Verify insertion
        face = clasificador.get_face(face_id)
        assert face is not None
        assert face["face_id"] == face_id

        # 3. Update face
        update_data = {
            "name": "Persistent Name",
            "relationship": "test",
            "confidence": "medium",
        }
        clasificador.update_face(face_id, update_data)

        # 4. Verify update persisted
        updated_face = clasificador.get_face(face_id)
        assert updated_face is not None
        assert updated_face["name"] == "Persistent Name"
        assert updated_face["relationship"] == "test"

        # 5. Verify face appears in unclassified list (since name is set now,
        # it shouldn't)
        unclassified = clasificador.get_unclassified_faces()
        unclassified_ids = [f["face_id"] for f in unclassified]
        assert (
            face_id not in unclassified_ids
        )  # Face should not be unclassified anymore


@pytest.mark.integration
class TestFAISSIntegration:
    """Integration tests for FAISS operations"""

    def test_faiss_index_creation_and_search(self, shared_ml_models):
        """
        Integration test: Verify FAISS index can be created and searched
        """
        clasificador = shared_ml_models["clasificador"]

        # Verify FAISS index exists
        assert hasattr(clasificador, "index")

        if clasificador.index is not None:
            # Test that we can add vectors to the index
            initial_size = clasificador.index.ntotal

            # Create a test embedding vector
            test_embedding = np.random.random(512).astype(np.float32)
            test_embedding = test_embedding.reshape(1, -1)  # FAISS expects 2D array

            # Add to index
            clasificador.index.add(test_embedding)

            # Verify index size increased
            assert clasificador.index.ntotal == initial_size + 1

            # Test search functionality
            distances, indices = clasificador.index.search(test_embedding, k=1)

            # Should find the vector we just added
            assert len(distances[0]) == 1
            assert len(indices[0]) == 1

            # Distance to itself should be very small (essentially 0)
            assert distances[0][0] < 0.001
